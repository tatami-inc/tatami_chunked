<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_chunked: tatami bindings for chunked matrices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_chunked
   </div>
   <div id="projectbrief">Helpers to create custom chunked tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">tatami bindings for chunked matrices </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2README"></a> <img src="https://github.com/tatami-inc/tatami_chunked/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/tatami-inc/tatami_chunked/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/> <a href="https://codecov.io/gh/tatami-inc/tatami_chunked"><img src="https://codecov.io/gh/tatami-inc/tatami_chunked/branch/master/graph/badge.svg?token=Z189ORCLLR" alt="Codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1>Overview</h1>
<p>Consider the situation where a matrix is represented as a grid of equally-sized independent chunks, where extraction of a particular matrix row/column requires retrieval of data from all overlapping chunks. This is a common paradigm in random-access file formats like HDF5 where entire chunks are read from file at once. It can also be used for in-memory data structures where the data for each chunk can be efficiently compressed to reduce memory usage, e.g., the <code>ChunkedRleArraySeed</code> for run-length-encoding-compressed chunks from the <a href="https://bioconductor.org/packages/DelayedArray"><b>DelayedArray</b></a> R package. The <b><a class="el" href="namespacetatami__chunked.html" title="Methods to handle chunked tatami matrices.">tatami_chunked</a></b> library implements some common functionality for <b>tatami</b> extension developers to create their own chunked matrix representations.</p>
<h1>Features</h1>
<p>Given a rectangular grid of chunks that make up a chunked matrix, we define a "slab" as the set of chunks that overlap a single row or column (or some subset/contiguous block thereof). We typically want to load and cache an entire slab at once, ensuring that future requests to adjacent row/columns can just use the cached values rather than re-reading or decompressing the same chunks. The <b><a class="el" href="namespacetatami__chunked.html" title="Methods to handle chunked tatami matrices.">tatami_chunked</a></b> library provides the <code>LruSlabCache</code> and <code>OracularSlabCache</code> classes to facilitate caching of the slabs in <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a></code> extractors. The <code>TypicalSlabCacheWorkspace</code> class allows developers to easily switch between caching strategies, depending on whether an oracle is provided to predict the future access pattern.</p>
<p>The <code>CustomDenseChunkedMatrix</code> and <code>CustomSparseChunkedMatrix</code> classes implement the <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a></code> interface on top of a matrix of custom chunks. These classes automatically perform slab caching given a set of options including the maximum cache size (see the <code>CustomDenseChunkedMatrixOptions</code> and <code>CustomSparseChunkedMatrixOptions</code> classes). Developers can use this to quickly create matrix representations with arbitrary chunk compression schemes that can reduce the memory footprint, e.g., DEFLATE, run length encodings. Obviously, this comes at the cost of speed whereby the chunks must be unpacked to extract the relevant data - developers are expected to define an appropriate extraction method for dense/sparse chunks.</p>
<p>In simple cases, chunk extraction is "atomic", i.e., the entire chunk must be unpacked to extract a subset of data. Developers can then use the <code>SimpleDenseChunkWrapper</code> and <code>SimpleSparseChunkWrapper</code> to wrap these simple chunks for use in the <code>Custom*ChunkedMatrix</code> classes. These wrappers only need a method to inflate the entire chunk; they will automatically handle the extraction of the desired block/subset from each chunk. (More advanced developers may prefer to write their own extraction methods that avoid inflating the entire chunk, in which case these wrappers are not necessary.)</p>
<p>Still confused? Read the <a href="https://tatami-inc.github.io/tatami_chunked">documentation</a>.</p>
<h1>Building with CMake</h1>
<h2>CMake using <code>FetchContent</code></h2>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  tatami_chunked</div>
<div class="line">  GIT_REPOSITORY https://github.com/tatami-inc/tatami_chunked</div>
<div class="line">  GIT_TAG master # or any version of interest </div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(tatami_chunked)</div>
</div><!-- fragment --><p>Then you can link to <b><a class="el" href="namespacetatami__chunked.html" title="Methods to handle chunked tatami matrices.">tatami_chunked</a></b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe tatami_chunked)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE tatami_chunked)</div>
</div><!-- fragment --><h2>CMake using <code>find_package()</code></h2>
<p>You can install the library by cloning a suitable version of this repository and running the following commands:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DTATAMI_CHUNKED_TESTS=OFF</div>
<div class="line">cmake --build . --target install</div>
</div><!-- fragment --><p>Then you can use <code>find_package()</code> as usual:</p>
<div class="fragment"><div class="line">find_package(tatami_tatami_chunked CONFIG REQUIRED)</div>
<div class="line">target_link_libraries(mylib INTERFACE tatami::tatami_chunked)</div>
</div><!-- fragment --><h2>Manual</h2>
<p>If you're not using CMake, the simple approach is to just copy the files the <code>include/</code> subdirectory - either directly or with Git submodules - and include their path during compilation with, e.g., GCC's <code>-I</code>. This will also require the dependencies listed in the <a href="extern/CMakeLists.txt"><code>extern/CMakeLists.txt</code></a> file, namely the core <a href="https://github.com/tatami-inc/tatami"><b>tatami</b></a> library. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
