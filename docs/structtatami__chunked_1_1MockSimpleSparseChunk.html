<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_chunked: tatami_chunked::MockSimpleSparseChunk Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_chunked
   </div>
   <div id="projectbrief">Helpers to create custom chunked tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami__chunked.html">tatami_chunked</a></li><li class="navelem"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html">MockSimpleSparseChunk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structtatami__chunked_1_1MockSimpleSparseChunk-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami_chunked::MockSimpleSparseChunk Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Mock a simple sparse chunk for a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.  
 <a href="structtatami__chunked_1_1MockSimpleSparseChunk.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mock__sparse__chunk_8hpp_source.html">mock_sparse_chunk.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad6c1f27da026f8d947159884d5e4cd1f" id="r_ad6c1f27da026f8d947159884d5e4cd1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#ad6c1f27da026f8d947159884d5e4cd1f">value_type</a></td></tr>
<tr class="separator:ad6c1f27da026f8d947159884d5e4cd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aac93a4ea386e10341de5a0626fc6a5" id="r_a8aac93a4ea386e10341de5a0626fc6a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a></td></tr>
<tr class="separator:a8aac93a4ea386e10341de5a0626fc6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0eda6522f83a7e849148597ed8e3d150" id="r_a0eda6522f83a7e849148597ed8e3d150"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </td></tr>
<tr class="memitem:a0eda6522f83a7e849148597ed8e3d150"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a0eda6522f83a7e849148597ed8e3d150">extract</a> (<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">secondary_start</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">secondary_length</a>, <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">work</a>, std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#ad6c1f27da026f8d947159884d5e4cd1f">value_type</a> &gt; &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_values</a>, std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a> &gt; &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_indices</a>, <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">shift</a>) <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a></td></tr>
<tr class="separator:a0eda6522f83a7e849148597ed8e3d150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cf20517832532e1616769a14615cf1" id="r_a91cf20517832532e1616769a14615cf1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </td></tr>
<tr class="memitem:a91cf20517832532e1616769a14615cf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a91cf20517832532e1616769a14615cf1">extract</a> (<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">secondary_indices</a>, <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">work</a>, std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#ad6c1f27da026f8d947159884d5e4cd1f">value_type</a> &gt; &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_values</a>, std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a> &gt; &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_indices</a>, <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">shift</a>) <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a></td></tr>
<tr class="separator:a91cf20517832532e1616769a14615cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aacc656011869b48792e99e90b393110a" id="r_aacc656011869b48792e99e90b393110a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">static</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">constexpr</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#aacc656011869b48792e99e90b393110a">use_subset</a> = <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">false</a></td></tr>
<tr class="separator:aacc656011869b48792e99e90b393110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mock a simple sparse chunk for a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>
<p>Mock a simple sparse chunk for use inside a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. Each chunk should represent a 2-dimensional array of numeric values. The interface is "simple" as extraction of any data involves realization of the entire blob along the primary dimension (i.e., the dimension used to create instances of the various <code><a class="elRef" href="https://tatami-inc.github.io/tatami/namespacetatami.html#a9a542a16a6a2c2c1efdc7b6e9eae9040">tatami::SparseExtractor</a></code> classes), with no optimization for subsets of interest along that dimension. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad6c1f27da026f8d947159884d5e4cd1f" name="ad6c1f27da026f8d947159884d5e4cd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c1f27da026f8d947159884d5e4cd1f">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">double</a> <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#ad6c1f27da026f8d947159884d5e4cd1f">tatami_chunked::MockSimpleSparseChunk::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the value stored in this chunk. Implementations can use any numeric type. </p>

</div>
</div>
<a id="a8aac93a4ea386e10341de5a0626fc6a5" name="a8aac93a4ea386e10341de5a0626fc6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aac93a4ea386e10341de5a0626fc6a5">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">int</a> <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">tatami_chunked::MockSimpleSparseChunk::index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the index stored in this chunk. Implementations can use any integer type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0eda6522f83a7e849148597ed8e3d150" name="a0eda6522f83a7e849148597ed8e3d150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eda6522f83a7e849148597ed8e3d150">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a> tatami_chunked::MockSimpleSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>secondary_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>secondary_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#ad6c1f27da026f8d947159884d5e4cd1f">value_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accrow_</td><td>Whether the rows are the primary dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">secondary_start</td><td>Index of the first element on the secondary dimension to be extracted. If <code>accrow_ = true</code>, this is the first column, otherwise it is the first row. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">secondary_length</td><td>Number of elements on the secondary dimension to be extracted. If <code>accrow_ = true</code>, this is the number of columns, otherwise it is the number of rows. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of vectors in which to store the output values. The outer vector is of length no less than <code>primary_start + primary_length</code>; each inner vector corresponds to an element of the primary dimension. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the output indices. The outer vector is of length no less than <code>primary_start + primary_length</code>; each inner vector corresponds to an element of the primary dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>accrow_ = true</code>, we would extract data for all rows and a block of columns <code>[secondary_start, secondary_start + secondary_length)</code>; conversely, if <code>accrow_ = false</code>, we would extract data for all columns and a block of rows. For a non-zero entry in primary dimension index <code>p</code>, the value from the chunk should be appended to <code>output_values[p]</code>. The secondary index for this non-zero entry should be increased by <code>shift</code> and then appended to <code>output_indices[p]</code>. The method should maintain a strictly increasing order among the appended secondary indices. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here. Only the <code>accrow_</code> template parameter is explicitly passed when this method is called by <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>

</div>
</div>
<a id="a91cf20517832532e1616769a14615cf1" name="a91cf20517832532e1616769a14615cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cf20517832532e1616769a14615cf1">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a> tatami_chunked::MockSimpleSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>secondary_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#ad6c1f27da026f8d947159884d5e4cd1f">value_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html#a8aac93a4ea386e10341de5a0626fc6a5">index_type</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accrow_</td><td>Whether the rows are the primary dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">secondary_indices</td><td>Indices of the elements on the secondary dimension to be extracted. If <code>accrow_ = true</code>, these are column indices, otherwise these are row indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of vectors in which to store the output values. The outer vector is of length no less than <code>primary_start + primary_length</code>; each inner vector corresponds to an element of the primary dimension. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the output indices. The outer vector is of length no less than <code>primary_start + primary_length</code>; each inner vector corresponds to an element of the primary dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>accrow_ = true</code>, we would extract all rows and a subset of columns in <code>secondary_indices</code>; conversely, if <code>accrow_ = false</code>, we would extract data for all columns and a subset of rows. For a non-zero entry in primary dimension index <code>p</code>, the value from the chunk should be appended to <code>output_values[p]</code>. The secondary index for this non-zero entry should be increased by <code>shift</code> and then appended to <code>output_indices[p]</code>. The method should maintain a strictly increasing order among the appended secondary indices. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here. Only the <code>accrow_</code> template parameter is explicitly passed when this method is called by <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aacc656011869b48792e99e90b393110a" name="aacc656011869b48792e99e90b393110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc656011869b48792e99e90b393110a">&#9670;&#160;</a></span>use_subset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">constexpr</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> tatami_chunked::MockSimpleSparseChunk::use_subset = <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to extract a subset of elements on the primary dimension. This should be set to <code>false</code>, otherwise a <code><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html" title="Mock a subsettable sparse chunk for a CustomSparseChunkedMatrix.">MockSubsettedSparseChunk</a></code> is expected. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>tatami_chunked/<a class="el" href="mock__sparse__chunk_8hpp_source.html">mock_sparse_chunk.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
