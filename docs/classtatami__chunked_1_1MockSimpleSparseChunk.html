<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_chunked: tatami_chunked::MockSimpleSparseChunk Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_chunked
   </div>
   <div id="projectbrief">Helpers to create custom chunked tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami__chunked.html">tatami_chunked</a></li><li class="navelem"><a class="el" href="classtatami__chunked_1_1MockSimpleSparseChunk.html">MockSimpleSparseChunk</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classtatami__chunked_1_1MockSimpleSparseChunk-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami_chunked::MockSimpleSparseChunk Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Mock a simple sparse chunk for a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mock__sparse__chunk_8hpp_source.html">mock_sparse_chunk.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae9b3c43e0ac3b5895077605e86d0c5c5" id="r_ae9b3c43e0ac3b5895077605e86d0c5c5"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b3c43e0ac3b5895077605e86d0c5c5">value_type</a></td></tr>
<tr class="separator:ae9b3c43e0ac3b5895077605e86d0c5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae9fd80fc0efa359b4150697e7ce6dfa6" id="r_ae9fd80fc0efa359b4150697e7ce6dfa6"><td class="memTemplParams" colspan="2">template&lt;typename Index_ &gt; </td></tr>
<tr class="memitem:ae9fd80fc0efa359b4150697e7ce6dfa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9fd80fc0efa359b4150697e7ce6dfa6">extract</a> (bool row, Index_ non_target_start, Index_ non_target_length, <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;work, const std::vector&lt; <a class="el" href="#ae9b3c43e0ac3b5895077605e86d0c5c5">value_type</a> * &gt; &amp;output_values, const std::vector&lt; Index_ * &gt; &amp;output_indices, Index_ *output_number, Index_ shift) const</td></tr>
<tr class="separator:ae9fd80fc0efa359b4150697e7ce6dfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d265eba927944ca0342fa5fb52795c" id="r_af0d265eba927944ca0342fa5fb52795c"><td class="memTemplParams" colspan="2">template&lt;typename Index_ &gt; </td></tr>
<tr class="memitem:af0d265eba927944ca0342fa5fb52795c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0d265eba927944ca0342fa5fb52795c">extract</a> (bool row, const std::vector&lt; Index_ &gt; &amp;non_target_indices, <a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;work, const std::vector&lt; <a class="el" href="#ae9b3c43e0ac3b5895077605e86d0c5c5">value_type</a> * &gt; &amp;output_values, const std::vector&lt; Index_ * &gt; &amp;output_indices, Index_ *output_number, Index_ shift) const</td></tr>
<tr class="separator:af0d265eba927944ca0342fa5fb52795c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aacc656011869b48792e99e90b393110a" id="r_aacc656011869b48792e99e90b393110a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacc656011869b48792e99e90b393110a">use_subset</a> = false</td></tr>
<tr class="separator:aacc656011869b48792e99e90b393110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mock a simple sparse chunk for a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>
<p>Mock a simple sparse chunk for use inside a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. Each chunk should represent a 2-dimensional array of numeric values. The interface is "simple" as extraction of any data involves realization of the entire chunk's contents along the target dimension, with no attempt at optimization if only a subset of dimension elements are of interest. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae9b3c43e0ac3b5895077605e86d0c5c5" name="ae9b3c43e0ac3b5895077605e86d0c5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b3c43e0ac3b5895077605e86d0c5c5">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="#ae9b3c43e0ac3b5895077605e86d0c5c5">tatami_chunked::MockSimpleSparseChunk::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the value stored in this chunk. Implementations can use any numeric type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9fd80fc0efa359b4150697e7ce6dfa6" name="ae9fd80fc0efa359b4150697e7ce6dfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fd80fc0efa359b4150697e7ce6dfa6">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tatami_chunked::MockSimpleSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>non_target_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>non_target_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>work</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ae9b3c43e0ac3b5895077605e86d0c5c5">value_type</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_ *</td>          <td class="paramname"><span class="paramname"><em>output_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all elements of the target dimension into output buffers. For each element, this method will extract a contiguous block of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to extract rows from the chunk, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_start</td><td>Index of the start of a contiguous block of the non-target dimension to be extracted. If <code>row = true</code>, this is the first column, otherwise it is the first row. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_length</td><td>Length of the contiguous block of the non-target dimension to be extracted. If <code>row = true</code>, this is the number of columns, otherwise it is the number of rows. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>row = true</code>, we would extract data for all rows and a block of columns <code>[non_target_start, non_target_start + non_target_length)</code>; conversely, if <code>row = false</code>, we would extract data for all columns and a block of rows. Given a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target block should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here, as long as the types can be deduced. </p>

</div>
</div>
<a id="af0d265eba927944ca0342fa5fb52795c" name="af0d265eba927944ca0342fa5fb52795c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d265eba927944ca0342fa5fb52795c">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tatami_chunked::MockSimpleSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>non_target_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk_1_1Workspace.html">Workspace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>work</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#ae9b3c43e0ac3b5895077605e86d0c5c5">value_type</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_ *</td>          <td class="paramname"><span class="paramname"><em>output_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all elements of the target dimension into output buffers. For each element, this method will extract an indexed subset of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to extract rows from the chunk, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_indices</td><td>Indices of the elements on the non-target dimension to be extracted. If <code>row = true</code>, these are column indices, otherwise these are row indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>row = true</code>, we would extract all rows and a subset of columns in <code>non_target_indices</code>; conversely, if <code>row = false</code>, we would extract data for all columns and a subset of rows. Given a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target subset should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here, as long as the types can be deduced. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aacc656011869b48792e99e90b393110a" name="aacc656011869b48792e99e90b393110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc656011869b48792e99e90b393110a">&#9670;&#160;</a></span>use_subset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tatami_chunked::MockSimpleSparseChunk::use_subset = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to extract a subset of elements on the target dimension. This should be set to <code>false</code>, otherwise a <code><a class="el" href="classtatami__chunked_1_1MockSubsettedSparseChunk.html" title="Mock a subsettable sparse chunk for a CustomSparseChunkedMatrix.">MockSubsettedSparseChunk</a></code> is expected. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami_chunked/<a class="el" href="mock__sparse__chunk_8hpp_source.html">mock_sparse_chunk.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
