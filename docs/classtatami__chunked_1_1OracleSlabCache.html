<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_chunked: tatami_chunked::OracleSlabCache&lt; Id_, Index_, Slab_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_chunked
   </div>
   <div id="projectbrief">Helpers to create custom chunked tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami__chunked.html">tatami_chunked</a></li><li class="navelem"><a class="el" href="classtatami__chunked_1_1OracleSlabCache.html">OracleSlabCache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami__chunked_1_1OracleSlabCache-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami_chunked::OracleSlabCache&lt; Id_, Index_, Slab_ &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Oracle-aware cache for slabs.  
 <a href="classtatami__chunked_1_1OracleSlabCache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OracleSlabCache_8hpp_source.html">OracleSlabCache.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab2ec1decfa4cdbff71b673d1ef960488"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami__chunked_1_1OracleSlabCache.html#ab2ec1decfa4cdbff71b673d1ef960488">OracleSlabCache</a> (std::unique_ptr&lt; <a class="elRef" href="https://tatami-inc.github.io/tatami/structtatami_1_1Oracle.html">tatami::Oracle</a>&lt; Index_ &gt; &gt; oracle, size_t per_iteration, size_t num_slabs)</td></tr>
<tr class="separator:ab2ec1decfa4cdbff71b673d1ef960488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857c8bf4e3591429a2d897279a67a05"><td class="memTemplParams" colspan="2">template&lt;class Ifunction_ , class Sfunction_ , class Rfunction_ , class Afunction_ , class Pfunction_ &gt; </td></tr>
<tr class="memitem:a4857c8bf4e3591429a2d897279a67a05"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const Slab_ *, Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtatami__chunked_1_1OracleSlabCache.html#a4857c8bf4e3591429a2d897279a67a05">next</a> (Ifunction_ identify, Sfunction_ swap, Rfunction_ ready, Afunction_ allocate, Pfunction_ populate)</td></tr>
<tr class="separator:a4857c8bf4e3591429a2d897279a67a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Id_, typename Index_, class Slab_&gt;<br />
class tatami_chunked::OracleSlabCache&lt; Id_, Index_, Slab_ &gt;</div><p >Oracle-aware cache for slabs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Id_</td><td>Type of slab identifier, typically integer. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of row/column index produced by the oracle. </td></tr>
    <tr><td class="paramname">Slab_</td><td>Class for a single slab.</td></tr>
  </table>
  </dd>
</dl>
<p>Implement an oracle-aware cache for slabs. Each slab is defined as the set of chunks required to read a row/column (or a contiguous block/indexed subset thereof) during iteration through a <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a></code>. This cache can be used for <code>Matrix</code> representations where the data is costly to load (e.g., from file) and a <code><a class="elRef" href="https://tatami-inc.github.io/tatami/structtatami_1_1Oracle.html">tatami::Oracle</a></code> is provided to predict future accesses. In such cases, chunks of data can be loaded and cached such that any possible future request for an already-loaded slab will just fetch it from cache. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab2ec1decfa4cdbff71b673d1ef960488" name="ab2ec1decfa4cdbff71b673d1ef960488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ec1decfa4cdbff71b673d1ef960488">&#9670;&#160;</a></span>OracleSlabCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami__chunked_1_1OracleSlabCache.html">tatami_chunked::OracleSlabCache</a>&lt; Id_, Index_, Slab_ &gt;::OracleSlabCache </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="elRef" href="https://tatami-inc.github.io/tatami/structtatami_1_1Oracle.html">tatami::Oracle</a>&lt; Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>oracle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>per_iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_slabs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>Pointer to an <code><a class="elRef" href="https://tatami-inc.github.io/tatami/structtatami_1_1Oracle.html">tatami::Oracle</a></code> to be used for predictions. </td></tr>
    <tr><td class="paramname">per_iteration</td><td>Maximum number of predictions to make per iteration. </td></tr>
    <tr><td class="paramname">num_slabs</td><td>Maximum number of slabs to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4857c8bf4e3591429a2d897279a67a05" name="a4857c8bf4e3591429a2d897279a67a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4857c8bf4e3591429a2d897279a67a05">&#9670;&#160;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ &gt; </div>
<div class="memtemplate">
template&lt;class Ifunction_ , class Sfunction_ , class Rfunction_ , class Afunction_ , class Pfunction_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const Slab_ *, Index_ &gt; <a class="el" href="classtatami__chunked_1_1OracleSlabCache.html">tatami_chunked::OracleSlabCache</a>&lt; Id_, Index_, Slab_ &gt;::next </td>
          <td>(</td>
          <td class="paramtype">Ifunction_&#160;</td>
          <td class="paramname"><em>identify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sfunction_&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rfunction_&#160;</td>
          <td class="paramname"><em>ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Afunction_&#160;</td>
          <td class="paramname"><em>allocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pfunction_&#160;</td>
          <td class="paramname"><em>populate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Fetch the next slab according to the stream of predictions provided by the <code><a class="elRef" href="https://tatami-inc.github.io/tatami/structtatami_1_1Oracle.html">tatami::Oracle</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ifunction_</td><td>Function to identify the slab containing each predicted row/column. </td></tr>
    <tr><td class="paramname">Sfunction_</td><td>Function to swap two slabs' contents. </td></tr>
    <tr><td class="paramname">Rfunction_</td><td>Function to determine whether a slab object is a non-mock instance. </td></tr>
    <tr><td class="paramname">Afunction_</td><td>Function to allocate memory to a mock slab, to turn it into a non-mock instance. </td></tr>
    <tr><td class="paramname">Pfunction_</td><td>Function to populate zero, one or more slabs with their contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identify</td><td>Function that accepts an <code>i</code>, an <code>Index_</code> containing the predicted row/column index. This should return a pair containing (1) the identifier of the slab containing <code>i</code>, and (2) the index of row/column <code>i</code> inside that slab. This is typically defined as the index of the slab on the iteration dimension. For example, if each chunk takes up 10 rows, attempting to access row 21 would require retrieval of slab 2 and an offset of 1. </td></tr>
    <tr><td class="paramname">swap</td><td>Function that accepts two <code>Slab_&amp;</code> and swaps their contents. </td></tr>
    <tr><td class="paramname">ready</td><td>Function that accepts a <code>const Slab_&amp;</code> and returns a boolean indicating whether it has already been allocated. This should return <code>true</code> for objects that have been used in <code>allocate()</code>, and <code>false</code> otherwise. </td></tr>
    <tr><td class="paramname">allocate</td><td>Function that accepts a single default-initialized <code>Slab_</code> object, and allocates sufficient memory to it in order to hold a slab's contents when used in <code>populate()</code>. </td></tr>
    <tr><td class="paramname">populate</td><td>Function that accepts two arguments, <code>slabs_in_need</code> and <code>slab_data</code>. (1) <code>slabs_in_need</code> is a <code>const std::vector&lt;std::pair&lt;Id_, Index_&gt; &gt;&amp;</code> specifying the slabs to be populated. The first <code>Id_</code> element of each pair contains the slab identifier, i.e., the first element returned by the <code>identify</code> function. The second <code>Index_</code> element specifies the index of the <code>Slab_</code> in <code>slab_data</code> in which to store the contents of each slab. (2) <code>slab_data</code> is a <code>std::vector&lt;Slab_&gt;&amp;</code> containing the cached slab contents to be populated. This function should iterate over the <code>slabs_in_need</code> and populate the corresponding entries in <code>slab_data</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing (1) a pointer to a slab's contents and (2) the index of the next predicted row/column inside the retrieved slab. </dd></dl>
<p >Doing a linear scan across slabs to find the allocated but unused cache elements. This is the simplest and safest approach; trying to keep track of the unused caches would require a scan to fill a map/set anyway, and deleting an iterator from cache_exists only works if cache_exists actually contains all cache elements, which it might not be if we reached max_predictions without filling up the cache.</p>
<p >In any case, a linear scan should be pretty good for consecutive access; the first cache elements would be the oldest, so there wouldn't be any wasted iterations to find available cache elements.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami_chunked/<a class="el" href="OracleSlabCache_8hpp_source.html">OracleSlabCache.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
