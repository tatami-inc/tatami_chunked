<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_chunked: tatami_chunked::OracularVariableSlabCache&lt; Id_, Index_, Slab_, Size_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_chunked
   </div>
   <div id="projectbrief">Helpers to create custom chunked tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami__chunked.html">tatami_chunked</a></li><li class="navelem"><a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">OracularVariableSlabCache</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami__chunked_1_1OracularVariableSlabCache-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami_chunked::OracularVariableSlabCache&lt; Id_, Index_, Slab_, Size_ &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Oracle-aware cache for variable-size slabs.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OracularVariableSlabCache_8hpp_source.html">OracularVariableSlabCache.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0e7d5bdfeeb4664f9f56ad54ed05c5d" id="r_ab0e7d5bdfeeb4664f9f56ad54ed05c5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0e7d5bdfeeb4664f9f56ad54ed05c5d">OracularVariableSlabCache</a> (std::shared_ptr&lt; const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Oracle.html">tatami::Oracle</a>&lt; Index_ &gt; &gt; oracle, std::size_t max_size)</td></tr>
<tr class="separator:ab0e7d5bdfeeb4664f9f56ad54ed05c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa092185a77c8c89bc0a6d1e36c1f1c51" id="r_aa092185a77c8c89bc0a6d1e36c1f1c51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa092185a77c8c89bc0a6d1e36c1f1c51">OracularVariableSlabCache</a> (const <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">OracularVariableSlabCache</a> &amp;)=delete</td></tr>
<tr class="separator:aa092185a77c8c89bc0a6d1e36c1f1c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa290fe5e31bb85293df722b5f42fbc54" id="r_aa290fe5e31bb85293df722b5f42fbc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">OracularVariableSlabCache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa290fe5e31bb85293df722b5f42fbc54">operator=</a> (const <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">OracularVariableSlabCache</a> &amp;)=delete</td></tr>
<tr class="separator:aa290fe5e31bb85293df722b5f42fbc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab403b1e2b0a2ecad69bc21968041fa1a" id="r_ab403b1e2b0a2ecad69bc21968041fa1a"><td class="memItemLeft" align="right" valign="top">Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab403b1e2b0a2ecad69bc21968041fa1a">next</a> ()</td></tr>
<tr class="separator:ab403b1e2b0a2ecad69bc21968041fa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d30b8acb09e2efb2a68f55b1b2f1812" id="r_a8d30b8acb09e2efb2a68f55b1b2f1812"><td class="memTemplParams" colspan="2">template&lt;class Ifunction_ , class Ufunction_ , class Afunction_ , class Cfunction_ , class Pfunction_ &gt; </td></tr>
<tr class="memitem:a8d30b8acb09e2efb2a68f55b1b2f1812"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const Slab_ *, Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d30b8acb09e2efb2a68f55b1b2f1812">next</a> (Ifunction_ identify, Ufunction_ upper_size, Afunction_ actual_size, Cfunction_ create, Pfunction_ populate)</td></tr>
<tr class="separator:a8d30b8acb09e2efb2a68f55b1b2f1812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e95e22103c32b1fdae89d4b9d2785a" id="r_a79e95e22103c32b1fdae89d4b9d2785a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79e95e22103c32b1fdae89d4b9d2785a">get_max_size</a> () const</td></tr>
<tr class="separator:a79e95e22103c32b1fdae89d4b9d2785a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ccbc05354893026eb3863a36a0c4cd" id="r_a49ccbc05354893026eb3863a36a0c4cd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49ccbc05354893026eb3863a36a0c4cd">get_used_size</a> () const</td></tr>
<tr class="separator:a49ccbc05354893026eb3863a36a0c4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6817761f796b3c43e6572efaed034ff2" id="r_a6817761f796b3c43e6572efaed034ff2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6817761f796b3c43e6572efaed034ff2">get_num_slabs</a> () const</td></tr>
<tr class="separator:a6817761f796b3c43e6572efaed034ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Id_, typename Index_, class Slab_, typename Size_&gt;<br />
class tatami_chunked::OracularVariableSlabCache&lt; Id_, Index_, Slab_, Size_ &gt;</div><p>Oracle-aware cache for variable-size slabs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Id_</td><td>Type of slab identifier, typically integer. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of row/column index produced by the oracle. </td></tr>
    <tr><td class="paramname">Slab_</td><td>Class for a single slab. </td></tr>
    <tr><td class="paramname">Size_</td><td>Numeric type for the slab size.</td></tr>
  </table>
  </dd>
</dl>
<p>Implement an oracle-aware cache for variable-size slabs. Each slab is defined as the set of chunks required to read an element of the target dimension (or a contiguous block/indexed subset thereof) from a <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a></code>. This cache is similar to <code><a class="el" href="classtatami__chunked_1_1OracularSlabCache.html" title="Oracular-aware cache for slabs.">OracularSlabCache</a></code> but enables improved cache utilization when the slabs vary in size. For example, the number of non-zero entries in a sparse matrix might vary between slabs, so the cache could be optimized to fit more slabs into memory when they have fewer non-zeros.</p>
<p>The size of each slab is defined by <code>Size_</code>, which can be any non-negative measure of slab size. This could be the number of non-zero elements, or the number of dimension elements, or the size of the slab in bytes, etc., as long as its interpretation is consistent between slabs and with the <code>max_size</code> used in the constructor. Users can also differentiate between the estimated and actual size of the slab, if the latter is not known until after the slab has been loaded into memory, e.g., the number of non-zero entries in a file-backed sparse matrix.</p>
<p>When implementing <code>Slab_</code>, we generally suggest using a common memory pool that is referenced by each <code>Slab_</code> instance. This guarantees that the actual cache size does not exceed the limit associated with <code>max_size</code> when <code>Slab_</code> instances are re-used for different slabs. (Otherwise, if each <code>Slab_</code> allocates its own memory, re-use of an instance may cause its allocation to increase to the size of the largest encountered slab.) Callers may need to occasionally defragment the pool to ensure that enough memory is available for loading new slabs. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab0e7d5bdfeeb4664f9f56ad54ed05c5d" name="ab0e7d5bdfeeb4664f9f56ad54ed05c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e7d5bdfeeb4664f9f56ad54ed05c5d">&#9670;&#160;</a></span>OracularVariableSlabCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::OracularVariableSlabCache </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Oracle.html">tatami::Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>Pointer to an <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Oracle.html">tatami::Oracle</a></code> to be used for predictions. </td></tr>
    <tr><td class="paramname">max_size</td><td>Total size of all slabs to store in the cache. This may be zero, in which case no caching should be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa092185a77c8c89bc0a6d1e36c1f1c51" name="aa092185a77c8c89bc0a6d1e36c1f1c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa092185a77c8c89bc0a6d1e36c1f1c51">&#9670;&#160;</a></span>OracularVariableSlabCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::OracularVariableSlabCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleted as the cache holds persistent pointers. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa290fe5e31bb85293df722b5f42fbc54" name="aa290fe5e31bb85293df722b5f42fbc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa290fe5e31bb85293df722b5f42fbc54">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">OracularVariableSlabCache</a> &amp; <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deleted as the cache holds persistent pointers. </p>

</div>
</div>
<a id="ab403b1e2b0a2ecad69bc21968041fa1a" name="ab403b1e2b0a2ecad69bc21968041fa1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab403b1e2b0a2ecad69bc21968041fa1a">&#9670;&#160;</a></span>next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index_ <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::next </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is intended to be called when <code>max_size = 0</code>, to provide callers with the oracle predictions for non-cached extraction of data. Calls to this method should not be intermingled with calls to its overload below; the latter should only be called when <code>max_size &gt; 0</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The next prediction from the oracle. </dd></dl>

</div>
</div>
<a id="a8d30b8acb09e2efb2a68f55b1b2f1812" name="a8d30b8acb09e2efb2a68f55b1b2f1812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d30b8acb09e2efb2a68f55b1b2f1812">&#9670;&#160;</a></span>next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<div class="memtemplate">
template&lt;class Ifunction_ , class Ufunction_ , class Afunction_ , class Cfunction_ , class Pfunction_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const Slab_ *, Index_ &gt; <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::next </td>
          <td>(</td>
          <td class="paramtype">Ifunction_</td>          <td class="paramname"><span class="paramname"><em>identify</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ufunction_</td>          <td class="paramname"><span class="paramname"><em>upper_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Afunction_</td>          <td class="paramname"><span class="paramname"><em>actual_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cfunction_</td>          <td class="paramname"><span class="paramname"><em>create</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pfunction_</td>          <td class="paramname"><span class="paramname"><em>populate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fetch the next slab according to the stream of predictions provided by the <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Oracle.html">tatami::Oracle</a></code>. This method should only be called if <code>max_size &gt; 0</code> in the constructor; otherwise, no slabs are actually available and cannot be returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ifunction_</td><td>Function to identify the slab containing each predicted row/column. </td></tr>
    <tr><td class="paramname">Ufunction_</td><td>Function to compute the estimated size of a slab. </td></tr>
    <tr><td class="paramname">Afunction_</td><td>Function to compute the actual size of a slab. </td></tr>
    <tr><td class="paramname">Cfunction_</td><td>Function to create a new slab. </td></tr>
    <tr><td class="paramname">Pfunction_</td><td>Function to populate zero, one or more slabs with their contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identify</td><td>Function that accepts an <code>i</code>, an <code>Index_</code> containing the predicted index of a single element on the target dimension. This should return a pair containing:<ol type="1">
<li>An <code>Id_</code>, the identifier of the slab containing <code>i</code>. This is typically defined as the index of the slab on the target dimension. For example, if each chunk takes up 10 rows, attempting to access row 21 would require retrieval of slab 2.</li>
<li>An <code>Index_</code>, the index of row/column <code>i</code> inside that slab. For example, if each chunk takes up 10 rows, attempting to access row 21 would yield an offset of 1. </li>
</ol>
</td></tr>
    <tr><td class="paramname">upper_size</td><td>Function that accepts <code>j</code>, an <code>Id_</code> containing the slab identifier. It should return the upper bound on the size of the slab as a non-negative <code>Size_</code>. This upper bound is typically different from the actual size when the latter is not known <em>a priori</em>, e.g., because the size is only known after populating the slab contents. However, if the latter is known, <code>upper_size()</code> may be a trivial function that returns the same value as <code>actual_size()</code>. </td></tr>
    <tr><td class="paramname">actual_size</td><td>Function that accepts <code>j</code>, an <code>Id_</code> containing the slab identifier; and <code>slab</code>, a populated <code>const Slab_&amp;</code> instance corresponding to <code>j</code>. It should return the actual size of the slab as a non-negative <code>Size_</code> that is no greater than <code>upper_size(j)</code>. </td></tr>
    <tr><td class="paramname">create</td><td>Function that accepts no arguments and returns a <code>Slab_</code> object with sufficient memory to hold a slab's contents when used in <code>populate()</code>. This may also return a default-constructed <code>Slab_</code> object if the allocation is done dynamically per slab in <code>populate()</code>. </td></tr>
    <tr><td class="paramname">populate</td><td>Function that accepts three arguments - <code>to_populate</code>, <code>to_reuse</code> and <code>all_slabs</code>.<ul>
<li>The <code>to_populate</code> argument is a <code>std::vector&lt;std::pair&lt;Id_, SlabIndex&gt; &gt;&amp;</code> specifying the slabs to be populated. The first <code>Id_</code> element of each pair contains the slab identifier, i.e., the first element returned by the <code>identify</code> function. The second <code>SlabIndex</code> element is an unsigned integer and the index of the entry of <code>all_slabs</code> containing the corresponding <code>Slab_</code> instance, as returned by <code>create()</code>. This argument can be modified in any manner. It is guaranteed to be non-empty but is not guaranteed to be sorted.</li>
<li>The <code>to_reuse</code> argument is a <code>std::vector&lt;std::pair&lt;Id_, SlabIndex&gt; &gt;&amp;</code> specifying the cached slabs that were re-used in the upcoming set of predictions. The elements of each pair are interpreted in the same manner as <code>to_populate</code>. This argument can be modified in any manner. It is not guaranteed to be non-empty or sorted.</li>
<li>The <code>all_slabs</code> argument is a <code>std::vector&lt;Slab_&gt;&amp;</code> containing all slabs in the cache. This may include instances that are not referenced by <code>to_populate</code> or <code>to_reuse</code>. Each element of this argument can be modified but the length should not change.</li>
</ul>
The <code>populate</code> function should iterate over <code>to_populate</code> and fill each <code>Slab_</code> with the contents of the corresponding slab. Optionally, callers may use <code>to_reuse</code> to defragment the already-in-use parts of the cache, in order to free up enough space for new data from <code>to_populate</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing (1) a pointer to a slab's contents and (2) the index of the next predicted row/column inside the retrieved slab. </dd></dl>

</div>
</div>
<a id="a79e95e22103c32b1fdae89d4b9d2785a" name="a79e95e22103c32b1fdae89d4b9d2785a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e95e22103c32b1fdae89d4b9d2785a">&#9670;&#160;</a></span>get_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::get_max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Maximum total size of the cache. This has the same value as the <code>max_size</code> used in the constructor. The type is an unsigned integer defined in <code>std::vector::size_type</code>. </dd></dl>

</div>
</div>
<a id="a49ccbc05354893026eb3863a36a0c4cd" name="a49ccbc05354893026eb3863a36a0c4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ccbc05354893026eb3863a36a0c4cd">&#9670;&#160;</a></span>get_used_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::get_used_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Current usage across all slabs in the cache. This should be interpreted as an upper bound on usage if there is a difference between estimated and actual slab sizes. The type is an unsigned integer defined in <code>std::vector::size_type</code>. </dd></dl>

</div>
</div>
<a id="a6817761f796b3c43e6572efaed034ff2" name="a6817761f796b3c43e6572efaed034ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6817761f796b3c43e6572efaed034ff2">&#9670;&#160;</a></span>get_num_slabs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ , typename Index_ , class Slab_ , typename Size_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtatami__chunked_1_1OracularVariableSlabCache.html">tatami_chunked::OracularVariableSlabCache</a>&lt; Id_, Index_, Slab_, Size_ &gt;::get_num_slabs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of slabs currently in the cache. The type is an unsigned integer defined in <code>std::vector::size_type</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami_chunked/<a class="el" href="OracularVariableSlabCache_8hpp_source.html">OracularVariableSlabCache.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
