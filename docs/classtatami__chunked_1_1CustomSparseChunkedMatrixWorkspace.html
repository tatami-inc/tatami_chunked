<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_chunked: tatami_chunked::CustomSparseChunkedMatrixWorkspace&lt; ChunkValue_, Index_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_chunked
   </div>
   <div id="projectbrief">Helpers to create custom chunked tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami__chunked.html">tatami_chunked</a></li><li class="navelem"><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrixWorkspace.html">CustomSparseChunkedMatrixWorkspace</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami__chunked_1_1CustomSparseChunkedMatrixWorkspace-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami_chunked::CustomSparseChunkedMatrixWorkspace&lt; ChunkValue_, Index_ &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Workspace for extracting data from a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrixManager.html" title="Manager of chunks for a CustomSparseChunkedMatrix.">CustomSparseChunkedMatrixManager</a></code>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CustomSparseChunkedMatrix_8hpp_source.html">CustomSparseChunkedMatrix.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae77be707bb332f71004fee1fbca1c7d8" id="r_ae77be707bb332f71004fee1fbca1c7d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae77be707bb332f71004fee1fbca1c7d8">extract</a> (Index_ chunk_row_id, Index_ chunk_column_id, bool row, Index_ target_start, Index_ target_length, Index_ non_target_start, Index_ non_target_length, const std::vector&lt; ChunkValue_ * &gt; &amp;output_values, const std::vector&lt; Index_ * &gt; &amp;output_indices, Index_ *output_number, Index_ shift)=0</td></tr>
<tr class="separator:ae77be707bb332f71004fee1fbca1c7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113bf432297bb091565dac7b14d142c1" id="r_a113bf432297bb091565dac7b14d142c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113bf432297bb091565dac7b14d142c1">extract</a> (Index_ chunk_row_id, Index_ chunk_column_id, bool row, Index_ target_start, Index_ target_length, const std::vector&lt; Index_ &gt; &amp;non_target_indices, const std::vector&lt; ChunkValue_ * &gt; &amp;output_values, const std::vector&lt; Index_ * &gt; &amp;output_indices, Index_ *output_number, Index_ shift)=0</td></tr>
<tr class="separator:a113bf432297bb091565dac7b14d142c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce7f02388b3fdc0f52618bb4c218eb4" id="r_a1ce7f02388b3fdc0f52618bb4c218eb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ce7f02388b3fdc0f52618bb4c218eb4">extract</a> (Index_ chunk_row_id, Index_ chunk_column_id, bool row, const std::vector&lt; Index_ &gt; &amp;target_indices, Index_ non_target_start, Index_ non_target_length, const std::vector&lt; ChunkValue_ * &gt; &amp;output_values, const std::vector&lt; Index_ * &gt; &amp;output_indices, Index_ *output_number, Index_ shift)=0</td></tr>
<tr class="separator:a1ce7f02388b3fdc0f52618bb4c218eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3787b12382b253cb5883b481a421ac39" id="r_a3787b12382b253cb5883b481a421ac39"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3787b12382b253cb5883b481a421ac39">extract</a> (Index_ chunk_row_id, Index_ chunk_column_id, bool row, const std::vector&lt; Index_ &gt; &amp;target_indices, const std::vector&lt; Index_ &gt; &amp;non_target_indices, const std::vector&lt; ChunkValue_ * &gt; &amp;output_values, const std::vector&lt; Index_ * &gt; &amp;output_indices, Index_ *output_number, Index_ shift)=0</td></tr>
<tr class="separator:a3787b12382b253cb5883b481a421ac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ChunkValue_, typename Index_&gt;<br />
class tatami_chunked::CustomSparseChunkedMatrixWorkspace&lt; ChunkValue_, Index_ &gt;</div><p>Workspace for extracting data from a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrixManager.html" title="Manager of chunks for a CustomSparseChunkedMatrix.">CustomSparseChunkedMatrixManager</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ChunkValue_</td><td>Numeric type of the data values in each chunk. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae77be707bb332f71004fee1fbca1c7d8" name="ae77be707bb332f71004fee1fbca1c7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77be707bb332f71004fee1fbca1c7d8">&#9670;&#160;</a></span>extract() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChunkValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrixWorkspace.html">tatami_chunked::CustomSparseChunkedMatrixWorkspace</a>&lt; ChunkValue_, Index_ &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_row_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_column_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>target_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>target_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>non_target_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>non_target_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ChunkValue_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_ *</td>          <td class="paramname"><span class="paramname"><em>output_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">chunk_row_id</td><td>Row of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">chunk_column_id</td><td>Column of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to extract rows from the chunk, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_start</td><td>Index of the first element on the target dimension to be extracted. If <code>row = true</code>, this is the first row, otherwise it is the first column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_length</td><td>Number of elements on the target dimension to be extracted. If <code>row = true</code>, this is the number of rows, otherwise it is the number of columns. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_start</td><td>Index of the start of the continguous block of the non-target dimension to be extracted. If <code>row = true</code>, this is the first column, otherwise it is the first row. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_length</td><td>Length of the contiguous block of the non-target dimension to be extracted. If <code>row = true</code>, this is the number of columns, otherwise it is the number of rows. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a chunk of interest, this method extracts a contiguous block of rows/columns. If <code>row = true</code>, we consider a block of rows <code>[target_start, target_start + target_length) * and a block of columns</code>[non_target_start, non_target_start + non_target_length)<code>; conversely, if</code>row = false<code>, we would consider a block of target columns and a block of non-target rows. For a target dimension element</code>p<code>, the values of non-zero elements from the requested non-target block should be stored at</code>output_values[p] + output_number[p]<code>. The non-target indices for those non-zero elements should be increased by</code>shift<code>and stored at</code>output_indices[p] + output_number[p]<code>in ascending order. </code>output_number[p]` should then be increased by the number of non-zero entries stored in this manner.</p>
<ul>
<li>Storing the non-zero values from the <code>output_number[p]</code>-th element onwards (and shifting their indices) allows interleaving of data from multiple chunks. This ensures that the values/indices from the same target dimension element are contiguous for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</li>
<li><code>p</code> should lie in <code>[target_start, target_start + target_length)</code>, not <code>[0, target_length)</code>. This difference is deliberate and enables easy extraction of the target dimension element of interest. </li>
</ul>

</div>
</div>
<a id="a113bf432297bb091565dac7b14d142c1" name="a113bf432297bb091565dac7b14d142c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113bf432297bb091565dac7b14d142c1">&#9670;&#160;</a></span>extract() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChunkValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrixWorkspace.html">tatami_chunked::CustomSparseChunkedMatrixWorkspace</a>&lt; ChunkValue_, Index_ &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_row_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_column_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>target_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>target_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>non_target_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ChunkValue_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_ *</td>          <td class="paramname"><span class="paramname"><em>output_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">chunk_row_id</td><td>Row of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">chunk_column_id</td><td>Column of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to extract rows from the chunk, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_start</td><td>Index of the first element on the target dimension to be extracted. If <code>row = true</code>, this is the first row, otherwise it is the first column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_length</td><td>Number of elements on the target dimension to be extracted. If <code>row = true</code>, this is the number of rows, otherwise it is the number of columns. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_indices</td><td>Indexed subset of the non-target dimension to be extracted. If <code>row = true</code>, these are column indices, otherwise these are row indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a chunk of interest, this method extracts a contiguous block along the target dimension and an indexed subset along the non-target dimension. If <code>row = true</code>, we consider a block of rows <code>[target_start, target_start + target_length)</code> and a subset of columns <code>non_target_indices</code>; conversely, if <code>row = false</code>, we would extract data for all columns and a subset of rows. For a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target subset should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner.</p>
<ul>
<li>Storing the non-zero values from the <code>output_number[p]</code>-th element onwards (and shifting their indices) allows interleaving of data from multiple chunks. This ensures that the values/indices from the same target dimension element are contiguous for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</li>
<li><code>p</code> should lie in <code>[target_start, target_start + target_length)</code>, not <code>[0, target_length)</code>. This difference is deliberate and enables easy extraction of the target dimension element of interest. </li>
</ul>

</div>
</div>
<a id="a1ce7f02388b3fdc0f52618bb4c218eb4" name="a1ce7f02388b3fdc0f52618bb4c218eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce7f02388b3fdc0f52618bb4c218eb4">&#9670;&#160;</a></span>extract() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChunkValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrixWorkspace.html">tatami_chunked::CustomSparseChunkedMatrixWorkspace</a>&lt; ChunkValue_, Index_ &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_row_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_column_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>non_target_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>non_target_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ChunkValue_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_ *</td>          <td class="paramname"><span class="paramname"><em>output_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">chunk_row_id</td><td>Row of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">chunk_column_id</td><td>Column of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to extract rows from the chunk, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_indices</td><td>Indices of the elements of the target dimension to be extracted. If <code>row = true</code>, these are row indices, otherwise these are column indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_start</td><td>Index of the start of the contiguous block of the non-target dimension to be extracted. If <code>row = true</code>, this is the first column, otherwise it is the first row. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_length</td><td>Length of the contiguous block of the non-target dimension to be extracted. If <code>row = true</code>, this is the number of columns, otherwise it is the number of rows. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a chunk of interest, this method extracts an indexed subset along the target dimension and a contiguous block along the non-target dimension. If <code>row = true</code>, we consider a subset of rows <code>target_indices</code> and a block of columns <code>[non_target_start, non_target_start + non_target_length)</code>; conversely, if <code>row = false</code>, we would extract a block of columns as the target and the block of rows as the non_target. For a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target block should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner.</p>
<ul>
<li>Storing the non-zero values from the <code>output_number[p]</code>-th element onwards (and shifting their indices) allows interleaving of data from multiple chunks. This ensures that the values/indices from the same target dimension element are contiguous for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</li>
<li><code>p</code> should be a value in <code>target_indices</code>, not <code>[0, target_indices.size())</code>. This difference is deliberate and enables easy extraction of the target dimension element of interest. </li>
</ul>

</div>
</div>
<a id="a3787b12382b253cb5883b481a421ac39" name="a3787b12382b253cb5883b481a421ac39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3787b12382b253cb5883b481a421ac39">&#9670;&#160;</a></span>extract() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChunkValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrixWorkspace.html">tatami_chunked::CustomSparseChunkedMatrixWorkspace</a>&lt; ChunkValue_, Index_ &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_row_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>chunk_column_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>non_target_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ChunkValue_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_ *</td>          <td class="paramname"><span class="paramname"><em>output_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">chunk_row_id</td><td>Row of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">chunk_column_id</td><td>Column of the chunk grid containing the chunk of interest. This considers the grid of chunks that is obtained by partitioning each dimension of the matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to extract rows from the chunk, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_indices</td><td>Indices of the elements on the target dimension to be extracted. If <code>row = true</code>, these are row indices, otherwise these are column indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_indices</td><td>Indices of the elements on the non-target dimension to be extracted. If <code>row = true</code>, these are column indices, otherwise these are row indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a chunk of interest, this method extracts data for an indexed subset of rows/columns. If <code>row = true</code>, we would extract a subset of rows in <code>target_indices</code> and a subset columns in <code>non_target_indices</code>. conversely, if <code>row = false</code>, we would consider a subset of target columns and a subset of non-target rows. For a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target subset should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner.</p>
<ul>
<li>Storing the non-zero values from the <code>output_number[p]</code>-th element onwards (and shifting their indices) allows interleaving of data from multiple chunks. This ensures that the values/indices from the same target dimension element are contiguous for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</li>
<li><code>p</code> should be a value in <code>target_indices</code>, not <code>[0, target_indices.size())</code>. This difference is deliberate and enables easy extraction of the target dimension element of interest. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami_chunked/<a class="el" href="CustomSparseChunkedMatrix_8hpp_source.html">CustomSparseChunkedMatrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
