<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami_chunked: tatami_chunked::MockSubsettedSparseChunk Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami_chunked
   </div>
   <div id="projectbrief">Helpers to create custom chunked tatami matrices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami__chunked.html">tatami_chunked</a></li><li class="navelem"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html">MockSubsettedSparseChunk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structtatami__chunked_1_1MockSubsettedSparseChunk-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami_chunked::MockSubsettedSparseChunk Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Mock a subsettable sparse chunk for a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.  
 <a href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mock__sparse__chunk_8hpp_source.html">mock_sparse_chunk.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3cfc7db47758a2d6d8252774185398de" id="r_a3cfc7db47758a2d6d8252774185398de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a></td></tr>
<tr class="separator:a3cfc7db47758a2d6d8252774185398de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54626ea9a02a3ee38216f230f4ea790" id="r_ae54626ea9a02a3ee38216f230f4ea790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a></td></tr>
<tr class="separator:ae54626ea9a02a3ee38216f230f4ea790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a423956f76bcf6de2dbb5cdb556773b38" id="r_a423956f76bcf6de2dbb5cdb556773b38"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </td></tr>
<tr class="memitem:a423956f76bcf6de2dbb5cdb556773b38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a423956f76bcf6de2dbb5cdb556773b38">extract</a> (<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">target_start</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">target_length</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">non_target_start</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">non_target_length</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">work</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_values</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_indices</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_number</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">shift</a>) <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a></td></tr>
<tr class="separator:a423956f76bcf6de2dbb5cdb556773b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87169460b16b3cc47f5bbc48a31e3c15" id="r_a87169460b16b3cc47f5bbc48a31e3c15"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </td></tr>
<tr class="memitem:a87169460b16b3cc47f5bbc48a31e3c15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a87169460b16b3cc47f5bbc48a31e3c15">extract</a> (<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">target_start</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">target_length</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">non_target_indices</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">work</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_values</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_indices</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_number</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">shift</a>) <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a></td></tr>
<tr class="separator:a87169460b16b3cc47f5bbc48a31e3c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038cea5cdb050ed663745a99c6a11561" id="r_a038cea5cdb050ed663745a99c6a11561"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </td></tr>
<tr class="memitem:a038cea5cdb050ed663745a99c6a11561"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a038cea5cdb050ed663745a99c6a11561">extract</a> (<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">target_indices</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">non_target_start</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">non_target_length</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">work</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_values</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_indices</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_number</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">shift</a>) <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a></td></tr>
<tr class="separator:a038cea5cdb050ed663745a99c6a11561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3d05a2fb76139268c5ab1c73e7e8d0" id="r_aee3d05a2fb76139268c5ab1c73e7e8d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </td></tr>
<tr class="memitem:aee3d05a2fb76139268c5ab1c73e7e8d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#aee3d05a2fb76139268c5ab1c73e7e8d0">extract</a> (<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">target_indices</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">non_target_indices</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">work</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_values</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_indices</a>, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">output_number</a>, <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">shift</a>) <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a></td></tr>
<tr class="separator:aee3d05a2fb76139268c5ab1c73e7e8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aeebcdcc7698b434223d503e96a8dd55d" id="r_aeebcdcc7698b434223d503e96a8dd55d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">static</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">constexpr</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#aeebcdcc7698b434223d503e96a8dd55d">use_subset</a> = <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">true</a></td></tr>
<tr class="separator:aeebcdcc7698b434223d503e96a8dd55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mock a subsettable sparse chunk for a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>
<p>Mock a subsettable sparse chunk for use inside a <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. Each chunk should represent a (possible compressed) 2-dimensional array of numeric values. The interface is smarter as it only extracts elements of interest along the target dimension. The elements of interest may be either a contiguous block or a indexed subset, as predicted for each chunk from the <code><a class="el" href="classtatami__chunked_1_1OracularSubsettedSlabCache.html" title="Oracle-aware cache for slabs, plus subsets.">OracularSubsettedSlabCache</a></code>. This provides some opportunities for optimization if the chunk supports partial reads. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3cfc7db47758a2d6d8252774185398de" name="a3cfc7db47758a2d6d8252774185398de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfc7db47758a2d6d8252774185398de">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">double</a> <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">tatami_chunked::MockSubsettedSparseChunk::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the value stored in this chunk. Implementations can use any numeric type. </p>

</div>
</div>
<a id="ae54626ea9a02a3ee38216f230f4ea790" name="ae54626ea9a02a3ee38216f230f4ea790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54626ea9a02a3ee38216f230f4ea790">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typedef</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">int</a> <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">tatami_chunked::MockSubsettedSparseChunk::index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the index stored in this chunk. Implementations can use any integer type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a423956f76bcf6de2dbb5cdb556773b38" name="a423956f76bcf6de2dbb5cdb556773b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423956f76bcf6de2dbb5cdb556773b38">&#9670;&#160;</a></span>extract() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a> tatami_chunked::MockSubsettedSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>target_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>target_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>non_target_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>non_target_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *&#160;</td>
          <td class="paramname"><em>output_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract a contiguous block of the target dimension into an output buffer. For each element, this method will only extract a contiguous block of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accrow_</td><td>Whether the rows are the target dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">target_start</td><td>Index of the start of a contiguous block of the target dimension to be extracted. If <code>accrow_ = true</code>, this is the first row, otherwise it is the first column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_length</td><td>Length of the contiguous block of the target dimension to be extracted. If <code>accrow_ = true</code>, this is the number of rows, otherwise it is the number of columns. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_start</td><td>Index of the start of a contiguous block of the non-target dimension to be extracted. If <code>accrow_ = true</code>, this is the first column, otherwise it is the first row. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_length</td><td>Length of the contiguous block of the non-target dimension to be extracted. If <code>accrow_ = true</code>, this is the number of columns, otherwise it is the number of rows. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>accrow_ = true</code>, we would extract a block of rows <code>[target_start, target_start + length)</code> and a block of columns <code>[non_target_start, non_target_start + non_target_length)</code>; conversely, if <code>accrow_ = false</code>, we would extract a block of columns from the <code>target_*</code> arguments and the block of rows from the <code>non_target_*</code>arguments. Given a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target block should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here. Only the <code>accrow_</code> template parameter is explicitly passed when this method is called by <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>

</div>
</div>
<a id="a87169460b16b3cc47f5bbc48a31e3c15" name="a87169460b16b3cc47f5bbc48a31e3c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87169460b16b3cc47f5bbc48a31e3c15">&#9670;&#160;</a></span>extract() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a> tatami_chunked::MockSubsettedSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>target_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>target_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>non_target_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *&#160;</td>
          <td class="paramname"><em>output_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract a contiguous block of the target dimension into an output buffer. For each element, this method will only extract an indexed subset of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accrow_</td><td>Whether the rows are the target dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">target_start</td><td>Index of the start of a contiguous block of the target dimension to be extracted. If <code>accrow_ = true</code>, this is the first row, otherwise it is the first column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">target_length</td><td>Length of the contiguous block of the target dimension to be extracted. If <code>accrow_ = true</code>, this is the number of rows, otherwise it is the number of columns. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_indices</td><td>Indices of the elements on the non-target dimension to be extracted. If <code>accrow_ = true</code>, these are column indices, otherwise these are row indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>accrow_ = true</code>, we would extract a block of rows <code>[target_start, target_start + length)</code> and a subset of columns in <code>non_target_indices</code>; conversely, if <code>accrow_ = false</code>, we would extract a block of columns from the <code>target_*</code> arguments and a subset of rows from <code>non_target_indices</code>. Given a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target subset should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here. Only the <code>accrow_</code> template parameter is explicitly passed when this method is called by <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>

</div>
</div>
<a id="a038cea5cdb050ed663745a99c6a11561" name="a038cea5cdb050ed663745a99c6a11561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038cea5cdb050ed663745a99c6a11561">&#9670;&#160;</a></span>extract() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a> tatami_chunked::MockSubsettedSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>non_target_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a>&#160;</td>
          <td class="paramname"><em>non_target_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *&#160;</td>
          <td class="paramname"><em>output_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract an indexed subset of the target dimension into an output buffer. For each element, this method will only extract a contiguous block of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accrow_</td><td>Whether the rows are the target dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">target_indices</td><td>Indices of the elements on the target dimension to be extracted. If <code>accrow_ = true</code>, these are row indices, otherwise these are column indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_start</td><td>Index of the start of a contiguous block of the non-target dimension to be extracted. If <code>accrow_ = true</code>, this is the first column, otherwise it is the first row. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_length</td><td>Length of the contiguous block of the non-target dimension to be extracted. If <code>accrow_ = true</code>, this is the number of columns, otherwise it is the number of rows. This is guaranteed to be positive. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>accrow_ = true</code>, we would extract a subset of rows in <code>target_indices</code> and a block of columns <code>[non_target_start, non_target_start + non_target_length)</code>, conversely, if <code>accrow_ = false</code>, we would extract a subset of columns from the <code>target_*</code> arguments and the block of rows from the <code>non_target_*</code> arguments. Given a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target block should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here. Only the <code>accrow_</code> template parameter is explicitly passed when this method is called by <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>

</div>
</div>
<a id="aee3d05a2fb76139268c5ab1c73e7e8d0" name="aee3d05a2fb76139268c5ab1c73e7e8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3d05a2fb76139268c5ab1c73e7e8d0">&#9670;&#160;</a></span>extract() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> accrow_, <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">typename</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">void</a> tatami_chunked::MockSubsettedSparseChunk::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>non_target_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk_1_1Workspace.html">Workspace</a> &amp;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#a3cfc7db47758a2d6d8252774185398de">value_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">const</a> std::vector&lt; <a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">Index_</a> *&#160;</td>
          <td class="paramname"><em>output_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtatami__chunked_1_1MockSubsettedSparseChunk.html#ae54626ea9a02a3ee38216f230f4ea790">index_type</a>&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract an indexed subset of the target dimension into an output buffer. For each element, this method will only extract an indexed subset of the non-target dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">accrow_</td><td>Whether the rows are the target dimension. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">target_indices</td><td>Indices of the elements on the target dimension to be extracted. If <code>accrow_ = true</code>, these are row indices, otherwise these are column indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">non_target_indices</td><td>Indices of the elements on the non-target dimension to be extracted. If <code>accrow_ = true</code>, these are column indices, otherwise these are row indices. This is guaranteed to be non-empty with unique and sorted indices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>Re-usable workspace for extraction from one or more chunks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_values</td><td>Vector of pointers in which to store the values of non-zero elements. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no values should be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_indices</td><td>Vector of vectors in which to store the indices of the non-zero elements along the non-target dimension. This has length equal to the extent of the target dimension for this chunk. Each pointer corresponds to an element of the target dimension and refers to an array of length no less than the extent of the non-target dimension of the chunk. Alternatively, this vector may be empty, in which case no indices should be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_number</td><td>Pointer to an array of length equal to the extent of the target dimension. Each entry <code>i</code> specifies the number of non-zero elements that are already present in <code>output_values[i]</code> and <code>output_indices[i]</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">shift</td><td>Shift to be added to the chunk's reported indices when storing them in <code>output_indices</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>accrow_ = true</code>, we would extract a subset of rows in <code>target_indices</code> and a subset of columns in <code>non_target_indices</code>. conversely, if <code>accrow_ = false</code>, we would extract a subset of columns in <code>target_indices</code> and the subset of rows in <code>non_target_indices</code>. Given a target dimension element <code>p</code>, the values of non-zero elements from the requested non-target subset should be stored at <code>output_values[p] + output_number[p]</code>. The non-target indices for those non-zero elements should be increased by <code>shift</code> and stored at <code>output_indices[p] + output_number[p]</code> in ascending order. <code>output_number[p]</code> should then be increased by the number of non-zero entries stored in this manner. This layout allows concatenation of multiple sparse chunks into a single set of vectors for easier fetching in the <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>.</p>
<p>Note that implementions of this method do not need to have the exact same template arguments as shown here. Only the <code>accrow_</code> template parameter is explicitly passed when this method is called by <code><a class="el" href="classtatami__chunked_1_1CustomSparseChunkedMatrix.html" title="Matrix of custom sparse chunks.">CustomSparseChunkedMatrix</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aeebcdcc7698b434223d503e96a8dd55d" name="aeebcdcc7698b434223d503e96a8dd55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebcdcc7698b434223d503e96a8dd55d">&#9670;&#160;</a></span>use_subset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">constexpr</a> <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">bool</a> tatami_chunked::MockSubsettedSparseChunk::use_subset = <a class="el" href="structtatami__chunked_1_1ChunkDimensionStats.html">true</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to extract a subset of elements on the target dimension. This should be set to <code>true</code>, otherwise a <code><a class="el" href="structtatami__chunked_1_1MockSimpleSparseChunk.html" title="Mock a simple sparse chunk for a CustomSparseChunkedMatrix.">MockSimpleSparseChunk</a></code> is expected. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>tatami_chunked/<a class="el" href="mock__sparse__chunk_8hpp_source.html">mock_sparse_chunk.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
